use std::time::{SystemTime, UNIX_EPOCH};

const SEVEN: [u8; 32] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07
];

/// curve's field prime
const P: [u8; 32] = [
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x2F
];

/// secp256k1 is short weierstrass curve
const B256: [u8; 32] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
];

const N: [u8; 32] = [
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xBA, 0xAE,
    0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B, 0xBF, 0xD2,
    0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41, 0x00, 0x00
];

const GX: [u8; 32] = [
    0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac,
    0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07,
    0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9,
    0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98
];

const GY: [u8; 32] = [
    0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65,
    0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8,
    0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19,
    0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8
];

fn mod_vec(a: &Vec<u8>, b: &Vec<u8>) -> Vec<u8> {
    // Convert `a` and `b` from `Vec<u8>` to `u128`
    // but here we will assume they fit into u128 for demonstration purposes.
    let mut a_int = 0u128;
    for &byte in a {
        a_int = (a_int << 8) + byte as u128;
    }

    let mut b_int = 0u128;
    for &byte in b {
        b_int = (b_int << 8) + byte as u128;
    }

    // Perform modulo operation
    let mut r = a_int % b_int;
    if r < 0 {
        r += b_int;
    }

    // Convert `r` back into `Vec<u8>`
    let mut result = Vec::new();
    for i in (0..16).rev() {
        result.push((r >> (i * 8)) as u8);
    }

    // Remove leading zero bytes if needed
    // while result.len() > 1 && result[0] == 0 {
    //     result.remove(0);
    // }

    result
}

fn get_random_values(buffer: &mut [u8]) {
    // Seed with the current time (not cryptographically secure).
    let start = SystemTime::now();
    let seed = start.duration_since(UNIX_EPOCH).expect("Time went backwards").as_secs() as u64;

    let mut random_seed = seed;
    for byte in buffer.iter_mut() {
        // Simple pseudo-random value by modifying the seed in each iteration
        random_seed ^= random_seed << 13;
        random_seed ^= random_seed >> 7;
        random_seed ^= random_seed << 17;
        *byte = (random_seed & 0xFF) as u8;
    }
}

struct Curve {
    p: [u8; 32],
    n: [u8; 32],
    a: [u8; 32],
    b: [u8; 32],
    gx: [u8; 32],
    gy: [u8; 32]
}

impl Curve {
    pub fn new() -> Self {
        Curve {
            p: P.clone(),
            n: N.clone(),
            a: B256.clone(),
            b: SEVEN.clone(),
            gx: GX.clone(),
            gy: GY.clone()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn create_curve_struct() {
        let curve = Curve::new();
        assert!(curve.p == P, "Curve p not valid");
        assert!(curve.n == N, "Curve n not valid");
        assert!(curve.a == B256, "Curve a not valid");
        assert!(curve.b == SEVEN, "Curve b not valid");
        assert!(curve.gx == GX, "Curve gx not valid");
        assert!(curve.gy == GY, "Curve gy not valid");
    }
}
